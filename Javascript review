React is 
- a lean and focused component-based UI library. 
- focuses on component but it doesn't have all the features, 
- third-party libraries needed for additional functionality to ur app

Angular is:
- Complete component-based UI framework, packed with features. 
- Uses TypeScript
- Can be overkill for smaller projects

--------------------------------------------------------------------------------------
let & const

let : to declare variable values that are variables
const: to declare constant values that are set once and never changed


Arrow functions:
Normal function: function myFnc(){... }
const myFnc=()=>{...}


Exports & imports:
- default export : when there's only one object in the file
import person from './person.js' or
import prs from './person.js'
where the name of import is up to developers

- named export: when there's +2 objects in the files to be exported
import {smth} from './utility.js'
import {smth as Smth} from './utility.js'
import * as bundled from './utility.js' 

where u have to use the exact name defined in the file with the export keyword, or if you have multiple named exports in a file, u can import everything with this*
special character and then assign an alias and bundled


Classes:
- Classe is a blueprint for objects 
- comparable to constructor functions where inheritance is comparable to prototypes
- property (variable)
- methods (funtions)
- convenient way of creating constructor functions
- support inheritance (you have another class which you inherit from taking all its properties and methods and potentially adding new methods and properties)

class Person{
	constructor () {
    }                           'a property is added by creating a constructor that is a default function method you can add to any class
}

=> if you're extending another class and you're implementing the constructor which you don't have to, then you have to add super() method in the constructor
this keyword simply excutes the parent constructor and initialize it.

----------------------------------------------------------------------------------------------------------
class Human{
  constructor(){
    this.gender='male';
  }
  printGender(){
    console.log(this.gender)
  }
}

class Person extends Human {

  constructor (){
    super();
    this.name='Max';
    //this.gender='female'; we can add/motify properties and methodes
    //console.log(this);
  }
 printMyName(){
   console.log(this.name)
 }
 
}

const person= new Person();
person.printMyName();
person.printGender();
------------------------------------------------------------------------------------
ES7 without constructor and super()
class Human{
 
    gender='male';

  printGender=()=>{
    console.log(this.gender);
  }
}

class Person extends Human {

    name='Max';
    gender='female';
    //this.gender='female'; we can add/motify properties and methodes
    //console.log(this);
  }
 printMyName=()=>{
   console.log(this.name);
 }
 
}

const person= new Person();
person.printMyName();
person.printGender();

---------------------------------------------------------------------------------------------------------------------------------------------

Spread & Rest Operators:
- Spread : used to split up array elements OR object properties
to pull out all the elements/properties of the old array/ object and add them to the new array/object
const newArray=[...oldArray,1,2]
const newObject={...oldObject, newProp:5}

const numbers=[1,2,3];
const newNumbers=[...numbers,4,5];
console.log(newNumbers);

const person={
  name:'max'
};

const newPerson= {
  ...person,
  age:28,
  gender: 'female'
}
console.log(newPerson);


- Rest: Used to merge a list of function arguments into an array 
we use it in a function argument list
function sorArgs(...args){
	return args.sort()
}

ex:
const filter=(...args)=>{ //...used as rest operator that merge arguments into an array
  return args.filter(el=>el===1); // now args is an array, we could use array filter method, in the filter method we can implement an arrow function to specify the criteria
}

console.log(filter(1,1,3))


-------------------------------------------------------------------------
Destructuring
- easily extract array elements or object properties and store them in variables

Destructuring vs spread :
- spread takes out all elements all properties and distributes them in a new array or object or wherever u're using it
- destructuring allows to pull out single element or properties and store them in variables for arrays and objects
   - Array destructuring
   ex: 
   const numbers=[1,2,3];
	[num1, num2]=numbers; // pull 1, 2 out of the numbers array
	console.log(num1,num2);
	
   const numbers=[1,2,3];
	[,num2 ,num3]=numbers; // pull 1, 2 out of the numbers array
	console.log(num2,num3); 
	
   - Object Destructuring 
   //https://dmitripavlutin.com/javascript-object-destructuring/
   //https://www.educative.io/answers/what-is-object-destructuring-in-javascript
   //https://javascript.info/destructuring-assignment
   ex:
   ({ nom} = { nom: 'jojo', age: 28 });
	console.log(nom);
	console.log(age);
 

-------------------------------------------------------------------------
Reference and primitive Types refresher
- numbers, strings, booleans, these are so-called primitive types. Whenever you reassign or you store a variable in another variable, it will copy the value
ex: 
const number = 1; //primitive type
const num2=number; // copy of number

console.log(num2);

- Objects and arrays are reference types
ex of copying the pointer:
const person={ //In the const Person store a pointer to the place where the object is stored in memory
  name: 'jojo'
};
const secondPerson=person; //reassignment => pointer is being copied
person.name='Manu';

console.log(secondPerson);

ex of copying the object: 
const person={ //In the const Person store a pointer to the place where the object is stored in memory
  name: 'jojo'
};
const secondPerson={ //create a new object
  ...person      //copy the object not the pointer
}
person.name='Manu';

console.log(secondPerson);

!!! Array and objects are reference type. If you reassign them you're copying the pointer not the value. Therefore if you want to do this in a real copy way, you will 
have to create a new onject.
-----------------------------------------------------------------------

Refreshing array functions
const
